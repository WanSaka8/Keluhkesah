<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
    import {
      getFirestore, collection, addDoc, serverTimestamp, onSnapshot, query, orderBy, deleteDoc, doc, updateDoc, arrayUnion, arrayRemove, increment, where, getDocs
    } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyD_sEU0Kn1Y15D0bfVw5gEvoJoU6slJUyA",
      authDomain: "keluhkesah-ec444.firebaseapp.com",
      projectId: "keluhkesah-ec444",
      storageBucket: "keluhkesah-ec444.firebasestorage.app",
      messagingSenderId: "96252446492",
      appId: "1:96252446492:web:1d1465382023793a189cd9",
      measurementId: "G-0N1ENCKMTN"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    let allNotes = [];
    let currentEditId = null;
    let currentFilter = 'all';
    let currentTimeFilter = 'all';
    let currentCategoryFilter = 'all';
    let currentSort = 'newest';
    let selectedMood = null;
    let selectedCategory = null;
    let isAnonymous = false;
    let userId = 'user_' + Math.random().toString(36).substr(2, 9);
    let voiceRecording = false;
    let mediaRecorder = null;
    let recordingChunks = [];

    // Challenges array
    const dailyChallenges = [
      "Ceritakan satu hal kecil yang membuat kamu tersenyum hari ini!",
      "Apa yang paling kamu syukuri minggu ini?",
      "Bagikan pengalaman belajar terbaru kamu!",
      "Ceritakan tentang seseorang yang menginspirasi kamu!",
      "Apa rencana kamu untuk menjadi versi terbaik dari diri kamu?",
      "Bagikan momen kebahagiaan sederhana yang kamu alami!",
      "Ceritakan tentang pencapaian kecil yang membuatmu bangga!"
    ];

    // Mood prediction words
    const moodWords = {
      happy: ['senang', 'bahagia', 'gembira', 'excited', 'amazing', 'bagus', 'mantap', 'keren', 'suka', 'cinta'],
      sad: ['sedih', 'down', 'kecewa', 'galau', 'hancur', 'putus', 'gagal', 'susah', 'sulit'],
      angry: ['kesel', 'marah', 'benci', 'jengkel', 'sebel', 'dongkol', 'emosi', 'geram'],
      excited: ['excited', 'antusias', 'semangat', 'energik', 'bersemangat', 'wow', 'keren', 'luar biasa'],
      confused: ['bingung', 'confused', 'pusing', 'ragu', 'tidak tahu', 'gimana', 'kayak gimana'],
      grateful: ['syukur', 'terima kasih', 'grateful', 'berkat', 'alhamdulillah', 'thanks']
    };

    // DOM elements
    const noteForm = document.getElementById('noteForm');
    const editForm = document.getElementById('editForm');
    const notesList = document.getElementById('notesList');
    const popularNotes = document.getElementById('popularNotes');
    const emptyState = document.getElementById('emptyState');
    const searchInput = document.getElementById('searchInput');
    const sortSelect = document.getElementById('sortSelect');
    const anonymousSwitch = document.getElementById('anonymousSwitch');
    const catatan = document.getElementById('catatan');
    const charCount = document.getElementById('charCount');
    const editCatatan = document.getElementById('editCatatan');
    const editCharCount = document.getElementById('editCharCount');
    const voiceBtn = document.getElementById('voiceBtn');
    const voiceStatus = document.getElementById('voiceStatus');

    // Initialize
    initializeEventListeners();
    loadNotes();
    loadWeather();
    generateDailyChallenge();
    generateMoodCalendar();
    
    const lastPage = localStorage.getItem('lastPage');
    if (lastPage && document.getElementById(lastPage)) {
      switchPage(lastPage);
    } else {
      switchPage('page-tulis');
    }

    function initializeEventListeners() {
      // Navigation
      document.getElementById('btn-tulis').addEventListener('click', () => switchPage('page-tulis'));
      document.getElementById('btn-daftar').addEventListener('click', () => switchPage('page-daftar'));
      document.getElementById('btn-trending').addEventListener('click', () => switchPage('page-trending'));
      document.getElementById('btn-analytics').addEventListener('click', () => switchPage('page-analytics'));
      document.getElementById('btn-mood-map').addEventListener('click', () => switchPage('page-mood-map'));

      // Forms
      noteForm.addEventListener('submit', handleSubmitNote);
      editForm.addEventListener('submit', handleEditNote);

      // Selectors
      document.querySelectorAll('.mood-option').forEach(option => {
        option.addEventListener('click', () => selectMood(option.dataset.mood));
      });

      document.querySelectorAll('.category-option').forEach(option => {
        option.addEventListener('click', () => selectCategory(option.dataset.category));
      });

      // Toggles and inputs
      anonymousSwitch.addEventListener('click', toggleAnonymous);
      catatan.addEventListener('input', () => {
        updateCharCount();
        predictMood();
      });
      editCatatan.addEventListener('input', updateEditCharCount);

      // Voice recording
      voiceBtn.addEventListener('click', toggleVoiceRecording);

      // Search and filters
      searchInput.addEventListener('input', filterNotes);
      sortSelect.addEventListener('change', (e) => {
        currentSort = e.target.value;
        filterNotes();
      });

      // Filter buttons
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', () => setFilter(btn.dataset.filter));
      });

      document.querySelectorAll('.time-btn').forEach(btn => {
        if (btn.dataset.time) {
          btn.addEventListener('click', () => setTimeFilter(btn.dataset.time));
        }
        if (btn.dataset.categoryFilter) {
          btn.addEventListener('click', () => setCategoryFilter(btn.dataset.categoryFilter));
        }
      });

      // Modal
      document.addEventListener('click', (e) => {
        if (e.target === document.getElementById('editModal')) {
          closeEditModal();
        }
      });
    }

    function selectMood(mood) {
      document.querySelectorAll('.mood-option').forEach(option => {
        option.classList.remove('selected');
      });
      document.querySelector(`[data-mood="${mood}"]`).classList.add('selected');
      selectedMood = mood;
    }

    function selectCategory(category) {
      document.querySelectorAll('.category-option').forEach(option => {
        option.classList.remove('selected');
      });
      document.querySelector(`[data-category="${category}"]`).classList.add('selected');
      selectedCategory = category;
    }

    function toggleAnonymous() {
      isAnonymous = !isAnonymous;
      anonymousSwitch.classList.toggle('active', isAnonymous);
      const namaInput = document.getElementById('nama');
      namaInput.disabled = isAnonymous;
      if (isAnonymous) {
        namaInput.value = 'Anonim';
        namaInput.style.background = '#f5f5f5';
      } else {
        namaInput.value = '';
        namaInput.style.background = 'rgba(255,255,255,0.9)';
      }
    }

    function updateCharCount() {
      const count = catatan.value.length;
      charCount.textContent = count;
      charCount.parentElement.classList.toggle('warning', count > 450);
    }

    function updateEditCharCount() {
      const count = editCatatan.value.length;
      editCharCount.textContent = count;
      editCharCount.parentElement.classList.toggle('warning', count > 450);
    }

    function predictMood() {
      const text = catatan.value.toLowerCase();
      let scores = {};
      
      Object.keys(moodWords).forEach(mood => {
        scores[mood] = 0;
        moodWords[mood].forEach(word => {
          if (text.includes(word)) {
            scores[mood]++;
          }
        });
      });

      const predictedMood = Object.keys(scores).reduce((a, b) => scores[a] > scores[b] ? a : b);
      const maxScore = Math.max(...Object.values(scores));
      
      if (maxScore > 0) {
        const moodEmojis = {
          happy: 'ğŸ˜Š',
          sad: 'ğŸ˜¢',
          angry: 'ğŸ˜ ',
          excited: 'ğŸ¤©',
          confused: 'ğŸ˜•',
          grateful: 'ğŸ™'
        };
        
        document.getElementById('predictedMood').textContent = moodEmojis[predictedMood];
        document.getElementById('moodPrediction').textContent = `Sepertinya kamu ${predictedMood}...`;
      } else {
        document.getElementById('predictedMood').textContent = 'ğŸ¤”';
        document.getElementById('moodPrediction').textContent = 'Tulis lebih banyak untuk prediksi yang akurat...';
      }
    }

    async function toggleVoiceRecording() {
      if (!voiceRecording) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream);
          recordingChunks = [];
          
          mediaRecorder.ondataavailable = (event) => {
            recordingChunks.push(event.data);
          };
          
          mediaRecorder.onstop = () => {
            const blob = new Blob(recordingChunks, { type: 'audio/wav' });
            // In a real app, you'd upload this to a speech-to-text service
            voiceStatus.textContent = 'Rekaman selesai! (Fitur speech-to-text akan datang)';
          };
          
          mediaRecorder.start();
          voiceRecording = true;
          voiceBtn.classList.add('recording');
          voiceStatus.textContent = 'Merekam... Klik lagi untuk berhenti';
          
        } catch (error) {
          showNotification('Browser tidak mendukung perekaman suara', 'error');
        }
      } else {
        mediaRecorder.stop();
        voiceRecording = false;
        voiceBtn.classList.remove('recording');
        voiceStatus.textContent = 'Klik untuk mulai merekam suara (opsional)';
      }
    }

    function generateDailyChallenge() {
      const today = new Date();
      const challengeIndex = today.getDate() % dailyChallenges.length;
      document.getElementById('dailyChallenge').textContent = dailyChallenges[challengeIndex];
    }

    function generateMoodCalendar() {
      const calendar = document.getElementById('moodCalendar');
      const today = new Date();
      const firstDay = new Date(today.getFullYear(), today.getMonth(), 1);
      const lastDay = new Date(today.getFullYear(), today.getMonth() + 1, 0);
      
      calendar.innerHTML = '';
      
      // Days of week header
      const daysOfWeek = ['Sen', 'Sel', 'Rab', 'Kam', 'Jum', 'Sab', 'Min'];
      daysOfWeek.forEach(day => {
        const dayHeader = document.createElement('div');
        dayHeader.style.cssText = 'text-align: center; font-weight: bold; padding: 0.5rem;';
        dayHeader.textContent = day;
        calendar.appendChild(dayHeader);
      });
      
      // Empty cells for days before month start
      const startDay = (firstDay.getDay() + 6) % 7; // Convert to Monday = 0
      for (let i = 0; i < startDay; i++) {
        const emptyDay = document.createElement('div');
        emptyDay.classList.add('mood-day');
        calendar.appendChild(emptyDay);
      }
      
      // Days of the month
      for (let day = 1; day <= lastDay.getDate(); day++) {
        const dayElement = document.createElement('div');
        dayElement.classList.add('mood-day');
        dayElement.style.background = day === today.getDate() ? '#4ecdc4' : '#f0f0f0';
        dayElement.style.color = day === today.getDate() ? 'white' : '#333';
        
        // Simulate random moods for past days
        if (day < today.getDate()) {
          const moods = ['ğŸ˜Š', 'ğŸ˜¢', 'ğŸ˜ ', 'ğŸ¤©', 'ğŸ˜•', 'ğŸ™'];
          dayElement.textContent = moods[day % moods.length];
        } else if (day === today.getDate()) {
          dayElement.textContent = selectedMood ? getMoodEmoji(selectedMood) : day;
        } else {
          dayElement.textContent = day;
          dayElement.style.opacity = '0.5';
        }
        
        dayElement.addEventListener('click', () => {
          if (day <= today.getDate()) {
            showNotification(`Mood tanggal ${day}: ${dayElement.textContent}`);
          }
        });
        
        calendar.appendChild(dayElement);
      }
    }

    async function loadWeather() {
      try {
        // Using a free weather API (you'd need to replace with actual API key)
        // For demo purposes, showing static weather
        const weatherWidget = document.getElementById('weatherWidget');
        const weather = ['â˜€ï¸ Cerah', 'â›… Berawan', 'ğŸŒ§ï¸ Hujan', 'ğŸŒ¤ï¸ Sebagian Cerah'];
        const randomWeather = weather[Math.floor(Math.random() * weather.length)];
        weatherWidget.innerHTML = `<span>${randomWeather}</span><span>28Â°C</span>`;
      } catch (error) {
        document.getElementById('weatherWidget').textContent = 'ğŸŒ¤ï¸ --Â°C';
      }
    }

    function toggleTheme() {
      document.body.classList.toggle('dark-mode');
      const isDark = document.body.classList.contains('dark-mode');
      localStorage.setItem('darkMode', isDark);
      document.querySelector('.theme-toggle').textContent = isDark ? 'â˜€ï¸' : 'ğŸŒ™';
    }

    // Load saved theme
    if (localStorage.getItem('darkMode') === 'true') {
      toggleTheme();
    }

    // Make toggleTheme global
    window.toggleTheme = toggleTheme;

    async function handleSubmitNote(e) {
      e.preventDefault();

      const nama = isAnonymous ? 'Anonim' : document.getElementById('nama').value.trim();
      const catatanText = catatan.value.trim();

      if ((!isAnonymous && !nama) || !catatanText || !selectedMood || !selectedCategory) {
        showNotification('Harap lengkapi semua field!', 'error');
        return;
      }

      if (catatanText.length > 500) {
        showNotification('Cerita terlalu panjang! Maksimal 500 karakter.', 'error');
        return;
      }

      try {
        await addDoc(collection(db, "notes"), {
          nama,
          catatan: catatanText,
          mood: selectedMood,
          category: selectedCategory,
          waktu: serverTimestamp(),
          likes: [],
          hearts: [],
          supports: [],
          comments: [],
          totalReactions: 0,
          userId: isAnonymous ? 'anonymous' : userId,
          isAnonymous
        });

        noteForm.reset();
        selectedMood = null;
        selectedCategory = null;
        document.querySelectorAll('.mood-option').forEach(option => {
          option.classList.remove('selected');
        });
        document.querySelectorAll('.category-option').forEach(option => {
          option.classList.remove('selected');
        });
        updateCharCount();
        
        // Update daily streak
        updateDailyStreak();

        showNotification('Cerita berhasil dikirim! ğŸ‰');
        switchPage('page-daftar');
      } catch (error) {
        console.error("Error adding document: ", error);
        showNotification('Terjadi kesalahan saat mengirim cerita.', 'error');
      }
    }

    async function handleEditNote(e) {
      e.preventDefault();

      const newText = editCatatan.value.trim();

      if (!newText) {
        showNotification('Cerita tidak boleh kosong!', 'error');
        return;
      }

      if (newText.length > 500) {
        showNotification('Cerita terlalu panjang! Maksimal 500 karakter.', 'error');
        return;
      }

      try {
        await updateDoc(doc(db, "notes", currentEditId), {
          catatan: newText,
          lastEdited: serverTimestamp()
        });

        showNotification('Cerita berhasil diupdate! âœ¨');
        closeEditModal();
      } catch (error) {
        console.error("Error updating document: ", error);
        showNotification('Terjadi kesalahan saat mengupdate cerita.', 'error');
      }
    }

    function openEditModal(id, currentText) {
      currentEditId = id;
      editCatatan.value = currentText;
      updateEditCharCount();
      document.getElementById('editModal').classList.add('active');
    }

    function closeEditModal() {
      document.getElementById('editModal').classList.remove('active');
      currentEditId = null;
      editCatatan.value = '';
    }

    window.closeEditModal = closeEditModal;

    async function toggleReaction(noteId, reactionType) {
      try {
        const noteRef = doc(db, "notes", noteId);
        const note = allNotes.find(n => n.id === noteId);

        if (!note) return;

        const userReacted = note[reactionType] && note[reactionType].includes(userId);

        if (userReacted) {
          await updateDoc(noteRef, {
            [reactionType]: arrayRemove(userId),
            totalReactions: increment(-1)
          });
        } else {
          await updateDoc(noteRef, {
            [reactionType]: arrayUnion(userId),
            totalReactions: increment(1)
          });
        }
      } catch (error) {
        console.error("Error toggling reaction: ", error);
        showNotification('Terjadi kesalahan saat memberikan reaksi.', 'error');
      }
    }

    async function addComment(noteId, comment) {
      if (!comment.trim()) return;
      
      try {
        const noteRef = doc(db, "notes", noteId);
        const commentData = {
          text: comment,
          author: isAnonymous ? 'Anonim' : document.getElementById('nama').value || 'Anonymous',
          userId: userId,
          timestamp: new Date().toISOString()
        };
        
        await updateDoc(noteRef, {
          comments: arrayUnion(commentData)
        });
        
        showNotification('Komentar berhasil ditambahkan! ğŸ’¬');
      } catch (error) {
        console.error("Error adding comment: ", error);
        showNotification('Terjadi kesalahan saat menambahkan komentar.', 'error');
      }
    }

    async function deleteNote(id) {
      if (confirm("Yakin ingin menghapus cerita ini?")) {
        try {
          await deleteDoc(doc(db, "notes", id));
          showNotification('Cerita berhasil dihapus! ğŸ—‘ï¸');
        } catch (error) {
          console.error("Error deleting document: ", error);
          showNotification('Terjadi kesalahan saat menghapus cerita.', 'error');
        }
      }
    }

    function shareNote(noteId) {
      const url = `${window.location.origin}${window.location.pathname}#note-${noteId}`;

      if (navigator.share) {
        navigator.share({
          title: 'Keluh Kesah',
          text: 'Lihat cerita menarik ini!',
          url: url
        });
      } else {
        navigator.clipboard.writeText(url).then(() => {
          showNotification('Link berhasil disalin! ğŸ”—');
        });
      }
    }

    function updateDailyStreak() {
      const today = new Date().toDateString();
      const lastPost = localStorage.getItem('lastPostDate');
      let streak = parseInt(localStorage.getItem('dailyStreak') || '0');
      
      if (lastPost !== today) {
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        
        if (lastPost === yesterday.toDateString()) {
          streak++;
        } else if (lastPost !== today) {
          streak = 1;
        }
        
        localStorage.setItem('dailyStreak', streak.toString());
        localStorage.setItem('lastPostDate', today);
        document.getElementById('dailyStreak').textContent = streak;
      }
    }

    function formatTime(timestamp) {
      if (!timestamp) return "Menunggu waktu...";

      const date = timestamp.toDate();
      const now = new Date();
      const diffInSeconds = Math.floor((now - date) / 1000);

      if (diffInSeconds < 60) {
        return "Baru saja";
      } else if (diffInSeconds < 3600) {
        const minutes = Math.floor(diffInSeconds / 60);
        return `${minutes} menit yang lalu`;
      } else if (diffInSeconds < 86400) {
        const hours = Math.floor(diffInSeconds / 3600);
        return `${hours} jam yang lalu`;
      } else if (diffInSeconds < 604800) {
        const days = Math.floor(diffInSeconds / 86400);
        return `${days} hari yang lalu`;
      } else {
        const options = {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        };
        return date.toLocaleDateString('id-ID', options);
      }
    }

    function getMoodBadgeClass(mood) {
      return `mood-${mood}`;
    }

    function getMoodEmoji(mood) {
      const emojis = {
        happy: 'ğŸ˜Š',
        sad: 'ğŸ˜¢',
        angry: 'ğŸ˜ ',
        excited: 'ğŸ¤©',
        confused: 'ğŸ˜•',
        grateful: 'ğŸ™'
      };
      return emojis[mood] || 'ğŸ˜';
    }

    function getCategoryEmoji(category) {
      const emojis = {
        personal: 'ğŸ‘¤',
        work: 'ğŸ’¼',
        family: 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦',
        love: 'ğŸ’•',
        health: 'ğŸ¥',
        education: 'ğŸ“'
      };
      return emojis[category] || 'ğŸ“';
    }

    function createNoteElement(docSnap) {
      const data = docSnap.data();
      const waktuFormatted = formatTime(data.waktu);
      const li = document.createElement("li");
      li.id = `note-${docSnap.id}`;

      const isOwner = data.userId === userId;
      const authorName = data.isAnonymous ? 'ğŸ‘¤ Anonim' : `ğŸ‘¤ ${data.nama}`;

      const likesCount = data.likes ? data.likes.length : 0;
      const heartsCount = data.hearts ? data.hearts.length : 0;
      const supportsCount = data.supports ? data.supports.length : 0;
      const commentsCount = data.comments ? data.comments.length : 0;

      const userLiked = data.likes ? data.likes.includes(userId) : false;
      const userHearted = data.hearts ? data.hearts.includes(userId) : false;
      const userSupported = data.supports ? data.supports.includes(userId) : false;

      li.innerHTML = `
        <div class="note-header">
          <div class="note-info">
            <div class="author-info">
              <span class="author-name">${authorName}</span>
              <span class="mood-badge ${getMoodBadgeClass(data.mood)}">${getMoodEmoji(data.mood)} ${data.mood}</span>
              ${data.category ? `<span class="category-badge">${getCategoryEmoji(data.category)} ${data.category}</span>` : ''}
            </div>
          </div>
        </div>
        <div class="note-text">${data.catatan}</div>
        
        <div class="comments-section">
          <div class="comments-toggle" onclick="toggleComments('${docSnap.id}')">
            ğŸ’¬ ${commentsCount} komentar ${commentsCount > 0 ? '(klik untuk lihat)' : ''}
          </div>
          <div class="comments-list" id="comments-${docSnap.id}" style="display: none;"></div>
          <div class="comment-form">
            <input type="text" class="comment-input" id="comment-input-${docSnap.id}" placeholder="Tulis komentar...">
            <button class="comment-btn" onclick="submitComment('${docSnap.id}')">Kirim</button>
          </div>
        </div>
        
        <div class="note-footer">
          <div class="timestamp">ğŸ•’ ${waktuFormatted}</div>
          <div class="reactions-section">
            <button class="reaction-btn ${userLiked ? 'active' : ''}" onclick="toggleReaction('${docSnap.id}', 'likes')">
              ğŸ‘ ${likesCount}
            </button>
            <button class="reaction-btn ${userHearted ? 'active' : ''}" onclick="toggleReaction('${docSnap.id}', 'hearts')">
              â¤ï¸ ${heartsCount}
            </button>
            <button class="reaction-btn ${userSupported ? 'active' : ''}" onclick="toggleReaction('${docSnap.id}', 'supports')">
              ğŸ¤— ${supportsCount}
            </button>
          </div>
          <div class="actions-section">
            <button class="action-btn edit-btn" onclick="openEditModal('${docSnap.id}', '${data.catatan.replace(/'/g, "\\'")}')" title="Edit">
              âœï¸ Edit
            </button>
            <button class="action-btn share-btn" onclick="shareNote('${docSnap.id}')" title="Bagikan">
              ğŸ”— Bagikan
            </button>
            <button class="action-btn delete-btn" onclick="deleteNote('${docSnap.id}')" title="Hapus">
              ğŸ—‘ï¸ Hapus
            </button>
          </div>
        </div>
      `;

      return li;
    }

    function toggleComments(noteId) {
      const commentsList = document.getElementById(`comments-${noteId}`);
      const isVisible = commentsList.style.display !== 'none';
      
      if (isVisible) {
        commentsList.style.display = 'none';
      } else {
        const note = allNotes.find(n => n.id === noteId);
        if (note && note.comments) {
          commentsList.innerHTML = note.comments.map(comment => `
            <div class="comment">
              <strong>${comment.author}:</strong> ${comment.text}
              <div style="font-size: 0.8em; color: #666; margin-top: 0.2rem;">
                ${new Date(comment.timestamp).toLocaleString('id-ID')}
              </div>
            </div>
          `).join('');
        }
        commentsList.style.display = 'block';
      }
    }

    function submitComment(noteId) {
      const input = document.getElementById(`comment-input-${noteId}`);
      const comment = input.value.trim();
      
      if (comment) {
        addComment(noteId, comment);
        input.value = '';
      }
    }

    function loadNotes() {
      const q = query(collection(db, "notes"), orderBy("waktu", "desc"));
      onSnapshot(q, (snapshot) => {
        allNotes = [];
        snapshot.forEach((docSnap) => {
          allNotes.push({
            id: docSnap.id,
            ...docSnap.data()
          });
        });

        updateStats();
        filterNotes();
        updatePopularNotes();
        updateAnalytics();
        generateWordCloud();
      });
    }

    function filterNotes() {
      let filteredNotes = [...allNotes];

      // Filter by search
      const searchTerm = searchInput.value.toLowerCase().trim();
      if (searchTerm) {
        filteredNotes = filteredNotes.filter(note =>
          note.catatan.toLowerCase().includes(searchTerm) ||
          note.nama.toLowerCase().includes(searchTerm) ||
          (note.category && note.category.toLowerCase().includes(searchTerm))
        );
      }

      // Filter by mood
      if (currentFilter !== 'all') {
        filteredNotes = filteredNotes.filter(note => note.mood === currentFilter);
      }

      // Filter by time
      if (currentTimeFilter !== 'all') {
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
        const monthAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);

        filteredNotes = filteredNotes.filter(note => {
          if (!note.waktu) return false;
          const noteDate = note.waktu.toDate();
          
          switch (currentTimeFilter) {
            case 'today':
              return noteDate >= today;
            case 'week':
              return noteDate >= weekAgo;
            case 'month':
              return noteDate >= monthAgo;
            default:
              return true;
          }
        });
      }

      // Filter by category
      if (currentCategoryFilter !== 'all') {
        filteredNotes = filteredNotes.filter(note => note.category === currentCategoryFilter);
      }

      // Sort
      filteredNotes.sort((a, b) => {
        switch (currentSort) {
          case 'oldest':
            return (a.waktu?.toDate() || 0) - (b.waktu?.toDate() || 0);
          case 'popular':
            return (b.totalReactions || 0) - (a.totalReactions || 0);
          case 'random':
            return Math.random() - 0.5;
          default: // newest
            return (b.waktu?.toDate() || 0) - (a.waktu?.toDate() || 0);
        }
      });

      displayNotes(filteredNotes);
    }

    function displayNotes(notes) {
      notesList.innerHTML = "";

      if (notes.length === 0) {
        emptyState.style.display = "block";
        return;
      }

      emptyState.style.display = "none";

      notes.forEach((note) => {
        const li = createNoteElement({ id: note.id, data: () => note });
        notesList.appendChild(li);
      });
    }

    function updatePopularNotes() {
      const popular = [...allNotes]
        .sort((a, b) => (b.totalReactions || 0) - (a.totalReactions || 0))
        .slice(0, 5);

      popularNotes.innerHTML = "";

      if (popular.length === 0) {
        popularNotes.innerHTML = '<li style="text-align: center; padding: 2rem; color: #666;">Belum ada cerita populer</li>';
        return;
      }

      popular.forEach((note) => {
        const li = createNoteElement({ id: note.id, data: () => note });
        popularNotes.appendChild(li);
      });
    }

    function generateWordCloud() {
      const wordFreq = {};
      const commonWords = ['dan', 'yang', 'di', 'ke', 'dari', 'untuk', 'dengan', 'pada', 'adalah', 'ini', 'itu', 'tidak', 'juga', 'atau', 'tapi', 'karena', 'saya', 'aku', 'kamu', 'dia'];
      
      allNotes.forEach(note => {
        const words = note.catatan.toLowerCase().split(/\s+/);
        words.forEach(word => {
          word = word.replace(/[^\w\s]/g, '');
          if (word.length > 3 && !commonWords.includes(word)) {
            wordFreq[word] = (wordFreq[word] || 0) + 1;
          }
        });
      });

      const sortedWords = Object.entries(wordFreq)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 15);

      const wordCloud = document.getElementById('wordCloud');
      wordCloud.innerHTML = sortedWords.map(([word, freq]) => {
        const size = Math.min(3, 1 + (freq / Math.max(...Object.values(wordFreq))) * 2);
        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#ff7675', '#74b9ff'];
        const color = colors[Math.floor(Math.random() * colors.length)];
        return `<span style="font-size: ${size}rem; color: ${color}; margin: 0.5rem;">${word}</span>`;
      }).join(' ');
    }

    function setFilter(filter) {
      currentFilter = filter;
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelector(`[data-filter="${filter}"]`).classList.add('active');
      filterNotes();
    }

    function setTimeFilter(timeFilter) {
      currentTimeFilter = timeFilter;
      document.querySelectorAll('[data-time]').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelector(`[data-time="${timeFilter}"]`).classList.add('active');
      filterNotes();
    }

    function setCategoryFilter(categoryFilter) {
      currentCategoryFilter = categoryFilter;
      document.querySelectorAll('[data-category-filter]').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelector(`[data-category-filter="${categoryFilter}"]`).classList.add('active');
      filterNotes();
    }

    function updateStats() {
      const totalPosts = allNotes.length;
      const totalLikes = allNotes.reduce((sum, note) => sum + (note.totalReactions || 0), 0);
      const uniqueUsers = new Set(allNotes.map(note => note.userId)).size;
      const dailyStreak = parseInt(localStorage.getItem('dailyStreak') || '0');

      document.getElementById('totalPosts').textContent = totalPosts;
      document.getElementById('totalLikes').textContent = totalLikes;
      document.getElementById('activeUsers').textContent = uniqueUsers;
      document.getElementById('dailyStreak').textContent = dailyStreak;
    }

    function updateAnalytics() {
      const totalPosts = allNotes.length;
      const totalReactions = allNotes.reduce((sum, note) => sum + (note.totalReactions || 0), 0);
      const avgReactions = totalPosts > 0 ? Math.round(totalReactions / totalPosts * 10) / 10 : 0;

      // Count moods
      const moodCounts = {};
      allNotes.forEach(note => {
        moodCounts[note.mood] = (moodCounts[note.mood] || 0) + 1;
      });

      const topMood = Object.keys(moodCounts).reduce((a, b) =>
        moodCounts[a] > moodCounts[b] ? a : b, 'happy');

      // Calculate most active hour
      const hourCounts = {};
      allNotes.forEach(note => {
        if (note.waktu) {
          const hour = note.waktu.toDate().getHours();
          hourCounts[hour] = (hourCounts[hour] || 0) + 1;
        }
      });
      
      const mostActiveHour = Object.keys(hourCounts).reduce((a, b) =>
        hourCounts[a] > hourCounts[b] ? a : b, '18');

      document.getElementById('totalPostsAnalytics').textContent = totalPosts;
      document.getElementById('totalReactionsAnalytics').textContent = totalReactions;
      document.getElementById('avgReactionsAnalytics').textContent = avgReactions;
      document.getElementById('topMoodAnalytics').textContent = getMoodEmoji(topMood);
      document.getElementById('activeHoursAnalytics').textContent = `${mostActiveHour}:00`;
      document.getElementById('longestStreakAnalytics').textContent = localStorage.getItem('longestStreak') || '0';

      // Update mood chart
      const moodChart = document.getElementById('moodChart');
      moodChart.innerHTML = '';

      Object.entries(moodCounts).forEach(([mood, count]) => {
        const percentage = totalPosts > 0 ? Math.round(count / totalPosts * 100) : 0;
        const bar = document.createElement('div');
        bar.style.cssText = `
          background: linear-gradient(45deg, #4ecdc4, #45b7d1);
          color: white;
          padding: 1rem;
          border-radius: 10px;
          text-align: center;
          min-width: 120px;
        `;
        bar.innerHTML = `
          <div style="font-size: 1.5rem;">${getMoodEmoji(mood)}</div>
          <div style="font-weight: bold;">${count}</div>
          <div style="font-size: 0.8rem;">${percentage}%</div>
        `;
        moodChart.appendChild(bar);
      });

      // Update activity chart
      const activityChart = document.getElementById('activityChart');
      const dayNames = ['Sen', 'Sel', 'Rab', 'Kam', 'Jum', 'Sab', 'Min'];
      
      // Skip the headers and update activity bars
      const dayCounts = [0, 0, 0, 0, 0, 0, 0];
      allNotes.forEach(note => {
        if (note.waktu) {
          const dayOfWeek = (note.waktu.toDate().getDay() + 6) % 7; // Convert to Monday = 0
          dayCounts[dayOfWeek]++;
        }
      });

      const maxCount = Math.max(...dayCounts) || 1;
      
      dayCounts.forEach((count, index) => {
        const intensity = count / maxCount;
        const activityBar = document.createElement('div');
        activityBar.style.cssText = `
          background: rgba(78, 205, 196, ${0.2 + intensity * 0.8});
          padding: 1rem;
          border-radius: 5px;
          text-align: center;
          font-weight: bold;
          color: ${intensity > 0.5 ? 'white' : '#333'};
        `;
        activityBar.textContent = count;
        activityChart.appendChild(activityBar);
      });
    }

    function switchPage(pageId) {
      document.querySelectorAll('.page').forEach(page => {
        page.classList.remove('active');
      });
      document.getElementById(pageId).classList.add('active');

      document.querySelectorAll('nav button').forEach(btn => {
        btn.classList.remove('active');
      });

      if (pageId === 'page-tulis') document.getElementById('btn-tulis').classList.add('active');
      else if (pageId === 'page-daftar') document.getElementById('btn-daftar').classList.add('active');
      else if (pageId === 'page-trending') document.getElementById('btn-trending').classList.add('active');
      else if (pageId === 'page-analytics') document.getElementById('btn-analytics').classList.add('active');
      else if (pageId === 'page-mood-map') document.getElementById('btn-mood-map').classList.add('active');

      localStorage.setItem('lastPage', pageId);
      
      // Update mood calendar when switching to mood map page
      if (pageId === 'page-mood-map') {
        generateMoodCalendar();
      }
    }

    function showNotification(message, type = 'success') {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.className = `notification ${type}`;
      notification.classList.add('show');

      setTimeout(() => {
        notification.classList.remove('show');
      }, 3000);
    }

    // Make functions global for onclick handlers
    window.toggleReaction = toggleReaction;
    window.deleteNote = deleteNote;
    window.shareNote = shareNote;
    window.openEditModal = openEditModal;
    window.toggleComments = toggleComments;
    window.submitComment = submitComment;

    // Auto-refresh features
    setInterval(() => {
      // Update relative timestamps
      if (document.getElementById('page-daftar').classList.contains('active') ||
          document.getElementById('page-trending').classList.contains('active')) {
        document.querySelectorAll('.timestamp').forEach(timestamp => {
          // Timestamps will be updated on next Firebase update
        });
      }
      
      // Update daily challenge
      generateDailyChallenge();
      
      // Update weather
      loadWeather();
    }, 60000);

    // Handle deep linking to specific notes
    if (window.location.hash.startsWith('#note-')) {
      const noteId = window.location.hash.substring(6);
      setTimeout(() => {
        const noteElement = document.getElementById(`note-${noteId}`);
        if (noteElement) {
          switchPage('page-daftar');
          noteElement.scrollIntoView({ behavior: 'smooth' });
          noteElement.style.animation = 'pulse 2s ease-in-out';
        }
      }, 1000);
    }

    // Initialize streak counter
    const currentStreak = parseInt(localStorage.getItem('dailyStreak') || '0');
    const longestStreak = parseInt(localStorage.getItem('longestStreak') || '0');
    if (currentStreak > longestStreak) {
      localStorage.setItem('longestStreak', currentStreak.toString());
    }
  </script>





async function loadWeather() {
      const weatherWidget = document.getElementById('weatherWidget');
      const lat = 3.5952;   // Medan latitude
      const lon = 98.6722;  // Medan longitude
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,wind_speed_10m&timezone=Asia%2FJakarta`;

      try {
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();
        const c = data.current;

        const { emoji, desc } = mapWeatherCode(c.weather_code);

        const updatedAt = new Date(c.time).toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' });

        // Build compact widget UI
        weatherWidget.innerHTML = `
        <span>${emoji}</span>
        <span>${desc}</span>
        <span>${Math.round(c.temperature_2m)}Â°C</span>
        <span>ğŸ’§${Math.round(c.relative_humidity_2m)}%</span>
        <span>ğŸ’¨${Math.round(c.wind_speed_10m)} km/j</span>
      `;
        weatherWidget.title = `Medan â€¢ Diperbarui ${updatedAt}`;
      } catch (err) {
        console.error("Gagal memuat cuaca:", err);
        weatherWidget.textContent = 'ğŸŒ¤ï¸ --Â°C';
      } finally {
        // refresh every 5 minutes
        setTimeout(loadWeather, 5 * 60 * 1000);
      }
    }

    function mapWeatherCode(code) {
      // Mapping Open-Meteo WMO weather codes ke emoji + deskripsi Bahasa
      const table = {
        0: { emoji: 'â˜€ï¸', desc: 'Cerah' },
        1: { emoji: 'ğŸŒ¤ï¸', desc: 'Sebagian cerah' },
        2: { emoji: 'â›…', desc: 'Berawan sebagian' },
        3: { emoji: 'â˜ï¸', desc: 'Berawan' },
        45: { emoji: 'ğŸŒ«ï¸', desc: 'Berkabut' },
        48: { emoji: 'ğŸŒ«ï¸', desc: 'Kabut membeku' },
        51: { emoji: 'ğŸŒ¦ï¸', desc: 'Gerimis ringan' },
        53: { emoji: 'ğŸŒ¦ï¸', desc: 'Gerimis sedang' },
        55: { emoji: 'ğŸŒ§ï¸', desc: 'Gerimis lebat' },
        56: { emoji: 'ğŸŒ§ï¸', desc: 'Gerimis beku ringan' },
        57: { emoji: 'ğŸŒ§ï¸', desc: 'Gerimis beku lebat' },
        61: { emoji: 'ğŸŒ¦ï¸', desc: 'Hujan ringan' },
        63: { emoji: 'ğŸŒ§ï¸', desc: 'Hujan sedang' },
        65: { emoji: 'ğŸŒ§ï¸', desc: 'Hujan lebat' },
        66: { emoji: 'ğŸŒ§ï¸', desc: 'Hujan beku ringan' },
        67: { emoji: 'ğŸŒ§ï¸', desc: 'Hujan beku lebat' },
        71: { emoji: 'â„ï¸', desc: 'Salju ringan' },
        73: { emoji: 'â„ï¸', desc: 'Salju sedang' },
        75: { emoji: 'â„ï¸', desc: 'Salju lebat' },
        77: { emoji: 'ğŸŒ¨ï¸', desc: 'Butiran salju' },
        80: { emoji: 'ğŸŒ¦ï¸', desc: 'Hujan lokal ringan' },
        81: { emoji: 'ğŸŒ§ï¸', desc: 'Hujan lokal sedang' },
        82: { emoji: 'â›ˆï¸', desc: 'Hujan lokal lebat' },
        85: { emoji: 'ğŸŒ¨ï¸', desc: 'Hujan salju ringan' },
        86: { emoji: 'ğŸŒ¨ï¸', desc: 'Hujan salju lebat' },
        95: { emoji: 'â›ˆï¸', desc: 'Badai petir' },
        96: { emoji: 'â›ˆï¸', desc: 'Badai petir + es kecil' },
        99: { emoji: 'â›ˆï¸', desc: 'Badai petir + es besar' },
      };
      return table[code] || { emoji: 'ğŸŒ¤ï¸', desc: 'Cuaca' };
    }

    // jalankan pas pertama kali load halaman
    loadWeather();